#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const double EPS = 1e-6;
const long double INF = 1231231231231;

typedef long double ptT;
struct pt
{
    ptT x, y;

    bool operator < (const pt &o) const
    {
        return make_pair(y, x) < make_pair(o.y, o.x);
    }
    bool operator == (const pt &o) const
    {
        return abs(x - o.x) < EPS and abs(o.y - y) < EPS;
    }

    pt operator - (const pt &o) const
    {
        return {x - o.x, y - o.y};
    }

    ptT operator ^ (const pt &o) const
    {
        return x * o.y - y * o.x;
    }

    ptT norm2() const
    {
        return x * x + y * y;
    }
};

int orientation(const pt &o, const pt &a, const pt &b)
{
    ptT cp = (b - o) ^ (a - o);
    return cp > EPS ? 1 : (cp < -EPS ? -1 : 0);
}

typedef vector <pt> polygon;
int next(int i, int sz, int s = 1)
{
    return (i + s) % sz;
}

polygon amchain(polygon &points)
{
    sort(points.begin(), points.end());

    polygon hull;

    for (int i = 0; i < 2; i ++)
    {
        int s = hull.size();
        for (pt &p : points)
        {
            while (hull.size() >= s + 2 and orientation(hull.rbegin()[1], hull.rbegin()[0], p) != 1)
                hull.pop_back();
            hull.push_back(p);
        }
        hull.pop_back();
        reverse(points.begin(), points.end());
    }
    if (hull.size() == 2 and hull[0] == hull[1]) hull.pop_back();
    return hull;
}

const pt origin = {0, 0};
double solve(const polygon &poly)
{
    int n = poly.size();
    auto best = INF;
    for (int i = 0, j = 1; i < n; i++)
    {
        while(true)
        {
            cout << i << " " << j << endl;

            auto vi = poly[i + 1] - poly[i];
            auto vj = poly[next(j, n)] - poly[j];

            auto orient = orientation(origin, vi, vj);

            if (orient != -1)
                j = next(j, n);
            else
                break;

        }
        auto vi = poly[i + 1] - poly[i];
        auto vj = poly[next(j, n)] - poly[j];


        auto possible = abs((poly[j] - poly[i]) ^ vi) / sqrt(vi.norm2());
        //auto possible2 = abs((poly[i] - poly[j]) ^ vj) / sqrt(vj.norm2());

        cout << "Pos: " << possible << endl;
        best = min(best, possible);
        //best = min(best, possible2);
        //cout << "End phase" << endl;

    }
    return best;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    int n, r;
    cin >> n >> r;

    vector <pt> points(n);
    for (int i = 0; i < n; i++)
    {
        cin >> points[i].x >> points[i].y;
    }

    auto poly = amchain(points);

    /*
    cout << "St"<<endl;
    for (auto p: poly)
    {
        cout << p.x << " " << p.y << endl;
    }
    cout << "EN"<<endl;
    */

    auto res = solve(poly);

    cout << fixed << setprecision(10) << res << '\n';
}